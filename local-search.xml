<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cdq分治</title>
    <link href="/2022/04/26/cdq/"/>
    <url>/2022/04/26/cdq/</url>
    
    <content type="html"><![CDATA[<h1 id="cdq分治">cdq分治</h1><p>cdq分治是cdq创造的一种分治算法，分治的思想就是<strong>划分</strong>问题，<strong>解决</strong>子问题，<strong>合并</strong>答案</p><p>cdq分治则是在合并子区间时，考虑左区间对右区间的影响，换言之，cdq分治解决的是前对后（按某种顺序）的单向影响的问题。</p><h2 id="例题">例题</h2><h3 id="p3810-模板三维偏序陌上花开"><a href="https://www.luogu.com.cn/problem/P3810">P3810【模板】三维偏序（陌上花开）</a></h3><h3 id="题目背景">题目背景</h3><p>这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。</p><h3 id="题目描述">题目描述</h3><p>有 <em>n</em> 个元素，第 i<em>i</em> 个元素有a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub> 三个属性，设 f(i) 表示满足a<sub>j</sub><em>≤</em>a<sub>i</sub> 且 b<sub>i</sub>≤b<sub>j</sub> 且c<sub>j</sub>≤c<sub>i</sub> 且 i≠j的<em>i</em> 和<em>j</em> 的数量。</p><p>对于 d<em>∈[0,</em>n)，求 f(i) = d的数量。</p><h3 id="输入格式">输入格式</h3><p>第一行两个整数 n,k 表示元素数量和最大属性值。</p><p>接下来 n行，每行三个整数 a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub>，分别表示三个属性值。</p><h3 id="输出格式">输出格式</h3><p><em>n</em> 行，第 d+1 行表示 f(i) = d 的 <em>i</em> 的数量。</p><h3 id="输入输出样例">输入输出样例</h3><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>1<br>3<br>0<br>1<br>0<br>1<br>0<br>0<br>1<br></code></pre></td></tr></table></figure><h3 id="说明提示">说明/提示</h3><p>1≤<em>n</em>≤10<sup>5</sup>，1≤a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub>≤<em>k</em>≤2×10<sup>5</sup>。</p><h3 id="代码">代码</h3><p>参考了luogu的这篇<a href="https://www.luogu.com.cn/blog/handsome-wzb/solution-p3810">博客</a></p><p>用我的语言整理一番</p><p>首先二维偏序的问题我们可以用树状数组轻松解决和求偏序的问题是相同的。</p><p>那么考虑三维比二维多一维，我们进行按其中一维排序然后分治，在这一维度左区间就比右区间小，考虑到我们的子问题分到了每一个元素，那么我们合并后就天然地解决了一维。这样，我们再将每个区间按省下两维排序，以求二维偏序的方法求一遍就可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> x,y,z,ans,cnt;<br>&#125; a1[N],a2[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a.x==b.x) &#123;<br><span class="hljs-keyword">if</span>(a.y==b.y)<span class="hljs-keyword">return</span> a.z&lt;b.z;<br><span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-keyword">return</span> a.x&lt;b.x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a.y==b.y)<span class="hljs-keyword">return</span> a.z&lt;b.z;<br><span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-type">int</span> c[N],ans[N];<br><span class="hljs-type">int</span> n,k,m=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span></span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;=k)&#123;<br>c[x]+=w;<br>x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>ret+=c[x];<br>x-=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">cdq</span>(l,mid);<br><span class="hljs-built_in">cdq</span>(mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">sort</span>(a2+l,a2+mid+<span class="hljs-number">1</span>,cmp2);<br><span class="hljs-built_in">sort</span>(a2+mid+<span class="hljs-number">1</span>,a2+r+<span class="hljs-number">1</span>,cmp2);<br><span class="hljs-type">int</span> i,j=l;<br><span class="hljs-keyword">for</span>(i=mid+<span class="hljs-number">1</span>; i&lt;=r; ++i) &#123;<br><span class="hljs-keyword">while</span>(a2[i].y&gt;=a2[j].y&amp;&amp;j&lt;=mid) &#123;<br><span class="hljs-built_in">update</span>(a2[j].z,a2[j].cnt);<br>j++;<br>&#125;<br>a2[i].ans+=<span class="hljs-built_in">query</span>(a2[i].z);<br>&#125;<br><span class="hljs-comment">//memset(c,0,sizeof(c));</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;j;i++)<span class="hljs-built_in">update</span>(a2[i].z,-a2[i].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>IOS<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a1[i].x&gt;&gt;a1[i].y&gt;&gt;a1[i].z;<br>&#125;<br><span class="hljs-built_in">sort</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+n,cmp1);<br><span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>top++;<br><span class="hljs-keyword">if</span>(a1[i].x!=a1[i+<span class="hljs-number">1</span>].x||a1[i].y!=a1[i+<span class="hljs-number">1</span>].y||a1[i].z!=a1[i+<span class="hljs-number">1</span>].z) &#123;<br>a2[++m].x=a1[i].x;<br>a2[m].y=a1[i].y;<br>a2[m].z=a1[i].z;<br>a2[m].cnt=top;<br>top=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>,m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>ans[a2[i].ans+a2[i].cnt<span class="hljs-number">-1</span>]+=a2[i].cnt;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cdq分治</tag>
      
      <tag>模板</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿豆蛙的归宿</title>
    <link href="/2022/04/22/%E7%BB%BF%E8%B1%86%E8%9B%99%E7%9A%84%E5%BD%92%E5%AE%BF/"/>
    <url>/2022/04/22/%E7%BB%BF%E8%B1%86%E8%9B%99%E7%9A%84%E5%BD%92%E5%AE%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="绿豆蛙的归宿"><a href="https://www.luogu.com.cn/problem/P4316">绿豆蛙的归宿</a></h1><h2 id="题目描述">题目描述</h2><p>给出张 n 个点 m 条边的有向无环图，起点为 1，终点为n，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。</p><p>绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有<em>k</em>条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 <span class="math inline">\(\frac{1}{k}\)</span>。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？</p><h2 id="输入格式">输入格式</h2><p>输入的第一行是两个整数，分别代表图的点数 <em>n</em> 和边数<em>m</em>。</p><p>第 2 到第(<em>m</em>+1) 行，每行有三个整数 u, v,w，代表存在一条从<em>u</em> 指向<em>v</em> 长度为<em>w</em>的有向边。</p><h2 id="输出格式">输出格式</h2><p>输出一行一个实数代表答案，四舍五入保留两位小数。</p><h2 id="输入输出样例">输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7</span>.<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h2 id="说明提示">说明/提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><ul><li>对于100% 的数据，保证1≤<em>n</em>≤10<sup>5</sup>，1≤<em>m</em>≤2×<em>n</em>，1≤<em>u</em>,<em>v</em>≤<em>n</em>，1≤<em>w</em>≤10<sup>9</sup>，给出的图无重边和自环。</li></ul><h2 id="思路">思路</h2><p>一般的期望dp都可以考虑正推或逆推，更关键的是要得出递推公式</p><p>初状态已知就正推，末状态已知就正推</p><p>考虑到此题的图的结构我们使用拓扑序加bfs来保证dp更新的顺序正确</p><h3 id="正推">正推</h3><p>设dp[i]表示从1到i的期望路径长度</p><p>g[i]表示从1到i的概率</p><p>从i出发，有k条路径，分别到达j<sub>1</sub>,j<sub>2</sub>,...,j<sub>n</sub>,路程为w<sub>1</sub>，w<sub>2</sub>,...,w<sub>n</sub></p><p>则可得<span class="math inline">\(dp[j]=(dp[i]+w_i\timesg[i]/k)\)</span> , <span class="math inline">\(g[j]=g[i]/k\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> v,w;<br>&#125;;<br><span class="hljs-type">double</span> dp[N],g[N];<br><span class="hljs-type">int</span> in[N],out[N];<br>vector&lt;node&gt;t[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>g[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>u=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:t[u])&#123;<br>dp[v.v]+=<span class="hljs-number">1.0</span>*(dp[u]+g[u]*v.w)/t[u].<span class="hljs-built_in">size</span>();<br>g[v.v]+=<span class="hljs-number">1.0</span>*g[u]/t[u].<span class="hljs-built_in">size</span>();<br>in[v.v]--;<br><span class="hljs-keyword">if</span>(in[v.v]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(v.v);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v,c;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;<br>t[u].<span class="hljs-built_in">push_back</span>(&#123;v,c&#125;);<br>in[v]++;<br>out[u]++;<br>&#125;<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,dp[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="逆推">逆推</h3><p>dp[i]表示i到终点经过的路径的期望长度</p><p>从i出发，有k条路径，分别到达j<sub>1</sub>,j<sub>2</sub>,...,j<sub>n</sub>,路程为w<sub>1</sub>，w<sub>2</sub>,...,w<sub>n</sub></p><p><span class="math inline">\(dp[i]=\frac{1}{k}\times(dp[j_1]+w_1)+\frac{1}{k}\times(dp[j_2]+w_2)+...+\frac{1}{k}\times(dp[j_k]+w_k)=\sum_{i=1}^kdp[j_i]+w_i\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> v,w;<br>&#125;;<br><span class="hljs-type">double</span> dp[N],g[N];<br><span class="hljs-type">int</span> in[N],siz[N];<br>vector&lt;node&gt;t[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>u=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:t[u])&#123;<br>dp[v.v]+=<span class="hljs-number">1.0</span>*(dp[u]+v.w)/siz[v.v];<br>in[v.v]--;<br><span class="hljs-keyword">if</span>(in[v.v]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(v.v);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v,c;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;<br>t[v].<span class="hljs-built_in">push_back</span>(&#123;u,c&#125;);<br>in[u]++;<br>siz[u]++;<br>&#125;<br><br><span class="hljs-built_in">bfs</span>(n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,dp[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期望dp</tag>
      
      <tag>拓扑序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆序对</title>
    <link href="/2022/04/21/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2022/04/21/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="p1908-逆序对"><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></h1><h2 id="题目描述">题目描述</h2><p>猫猫 TOM 和小老鼠 JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。</p><p>最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中a<sub>i</sub>&gt;a<sub>j</sub> 且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。</p><p><strong>Update:数据已加强。</strong></p><h2 id="输入格式">输入格式</h2><p>第一行，一个数 <em>n</em>，表示序列中有 n个数。</p><p>第二行 n* 个数，表示给定的序列。序列中每个数字不超过 10^9。</p><h2 id="输出格式">输出格式</h2><p>输出序列中逆序对的数目。</p><h2 id="输入输出样例">输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">11<br></code></pre></td></tr></table></figure><h2 id="说明提示">说明/提示</h2><p>对于所有数据，n*≤5×10<sup>5</sup></p><p>请使用较快的输入输出</p><h2 id="思路">思路</h2><p>先离散化，然后遍历，每扫一位就加入值大于当前位的个数，用树状数组计算个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],c[N];<span class="hljs-type">int</span> n;<br><span class="hljs-keyword">namespace</span> ls &#123; <span class="hljs-comment">//离散模板</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Nn=<span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> C[Nn],L[Nn],A[Nn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-type">int</span> *f,<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)A[i]=a[i+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memcpy</span>(C,A,<span class="hljs-built_in">sizeof</span>(A));<br><span class="hljs-built_in">sort</span>(C,C+n);<br><span class="hljs-type">int</span> l=<span class="hljs-built_in">unique</span>(C,C+n)-C;<br><span class="hljs-comment">//int l=n;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>L[i]=<span class="hljs-built_in">lower_bound</span>(C,C+l,A[i])-C+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)f[i+<span class="hljs-number">1</span>]=L[i];<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x)&amp;(-(x))</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span></span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>c[x]+=w;<br>x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>ret+=c[x];<br>x-=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>ls::<span class="hljs-built_in">ls</span>(a,a,n);<br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">update</span>(a[i],<span class="hljs-number">1</span>);<br>ans+=<span class="hljs-built_in">query</span>(n)-<span class="hljs-built_in">query</span>(a[i]);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>区间小于等于k的个数</title>
    <link href="/2022/04/13/%E5%8C%BA%E9%97%B4%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/04/13/%E5%8C%BA%E9%97%B4%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="区间小于等于k的个数">区间小于等于k的个数</h1><h2 id="例题"><a href="http://oj.daimayuan.top/problem/464">例题</a></h2><p>在给定 N 长的数组 A 中进行 Q 次询问 [Li,Ri]区间中<strong>不大于</strong> Hi 的元素个数</p><h2 id="思路">思路</h2><p>做这个题也是花了很久时间啊，做题看着代码改了一下午加一晚上，中间还做了道分块基础，今早还做不出，中午终于改对，感觉自己蠢爆了</p><p>然后讲思路，一般思路都是for套个while，但是这套我还没完全理解，下次更</p><p>这里是学习的这位的思路，<a href="https://zhuanlan.zhihu.com/p/475131851">严格鸽</a>，日更大佬orz</p><p>考虑到我们如果暴力的遍历每个区间中的的数，重叠的点被多次访问，浪费了时间。</p><p>于是我们换个角度，我们只把每个点遍历一遍，求点对区间的贡献。点对区间的贡献可以用前缀和来做，我们用树状数组动态地做这个前缀和。</p><p>要做到这点，我们先对A数组进行离散化。然后将查询的操作按L，R分开来做，一个点如果是L，对区间的贡献乘-1，如果是R就正常加上，这样对于一个查询我们就求出了他的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">namespace</span> ls &#123; <span class="hljs-comment">//离散模板</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Nn=<span class="hljs-number">5e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> C[Nn],L[Nn],A[Nn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-type">int</span> *f,<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)A[i]=a[i+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memcpy</span>(C,A,<span class="hljs-built_in">sizeof</span>(A));<br><span class="hljs-built_in">sort</span>(C,C+n);<br><span class="hljs-type">int</span> l=<span class="hljs-built_in">unique</span>(C,C+n)-C;<br><span class="hljs-comment">//int l=n;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>L[i]=<span class="hljs-built_in">lower_bound</span>(C,C+l,A[i])-C+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)f[i+<span class="hljs-number">1</span>]=L[i];<br>&#125;<br>&#125; <span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> L[N],R[N],a[N],H[N],f[N],ans[N],c[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> k,x,id;<br>&#125;;<br>vector&lt;node&gt;g[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (x&amp;(-x));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>) &#123;<br>ret+=c[x];<br>x-=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;=n+m) &#123;<br>c[x]+=d;<br>x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--) &#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)g[i].<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)cin&gt;&gt;L[i]&gt;&gt;R[i]&gt;&gt;a[n+i];<br>ls::<span class="hljs-built_in">ls</span>(f,a,n+m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)a[i]=f[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)H[i]=f[n+i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>g[L[i]<span class="hljs-number">-1</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">-1</span>,H[i],i&#125;);<br>g[R[i]].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>,H[i],i&#125;);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">update</span>(a[i],<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[i]) &#123;<br>ans[v.id]+=v.k*<span class="hljs-built_in">query</span>(v.x);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分块入门</title>
    <link href="/2022/04/12/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/12/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="分块入门">分块入门</h1><p>鸽子给了个链接https://www.luogu.com.cn/paste/btx82uof</p><p>稍微总结下</p><h2 id="数列分块入门-2区间加区间求和">数列分块入门2（区间加，区间求和）</h2><h3 id="题目链接"><a href="https://loj.ac/p/6278">题目链接</a></h3><h3 id="题目描述">题目描述</h3><p>给出一个长为 的数列，以及个操作，操作涉及区间加法，询问区间内小于某个值 的元素个数。</p><h3 id="输入格式">输入格式</h3><p>第一行输入一个数字 。</p><p>第二行输入 个数字，第 个数字为 ，以空格隔开。</p><p>接下来输入 行询问，每行输入四个数字 op、l、r、c，以空格隔开。</p><p>若op==1 ，表示将位于[l,r] 的之间的数字都加c 。</p><p>若op==2 ，表示询问 [l,r]中，小于c 的数字的个数。</p><h3 id="输出格式">输出格式</h3><p>对于每次询问，输出一行一个数字表示答案。</p><h3 id="样例输入">样例输入</h3><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出">样例输出</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>0<br>2<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>0<br>2<br></code></pre></td></tr></table></figure><h3 id="数据范围与提示">数据范围与提示</h3><p>1&lt;=n&lt;=50000,-2<sup>31</sup>&lt;ans,a<sub>i</sub>&lt;2<sup>31</sup></p><h3 id="思路">思路</h3><p>对一些区间操作我们可以将线段先分块再暴力处理零散块+排序二分处理整块</p><p>算块长我们根据复杂度来做，设块长为b</p><p>对于操作1我们O(<span class="math inline">\(b+\frac{n}{b}\)</span>)可以解决</p><p>对于操作2我们O(<span class="math inline">\(b+\frac{n}{b}logb\)</span>)</p><p>很显然操作2的复杂度大于操作1，因此我们用操作2来计算块长</p><p>b可以看作是n的多项式（poly n），因此<span class="math inline">\(logb\)</span>可以看作是<span class="math inline">\(logn\)</span>加一个常数，也就是<span class="math inline">\(logn\)</span></p><p>所以我们利用均值不等式 <span class="math display">\[b+\frac{n}{b}logn\ge2\sqrt{nlogn}\\等号在b=\frac{n}{b}logn时取到，此时b=\sqrt{nlogn}\]</span> 因此我们算出块长b=<span class="math inline">\(\sqrt{nlogn}\)</span>，复杂度为O(<span class="math inline">\(m\sqrt{nlogn}\)</span>)</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cn.tie(0);cout.tie(0);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bi(x) (((x)-1)/block)<span class="hljs-comment">//块序号</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sb(x) ((x)*block+1)<span class="hljs-comment">//每块开始位置 strat of block</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb(x) min(((x)+1)*block,n)<span class="hljs-comment">//每块结束位置 end of block</span></span><br><span class="hljs-comment">//基本是分块必备了</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-comment">/*1e4*/</span><span class="hljs-number">5e4</span>,block=<span class="hljs-number">888</span>;<br><span class="hljs-type">int</span> a[N],id[N],tag[<span class="hljs-built_in">bi</span>(N)+<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>id[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">bi</span>(<span class="hljs-number">1</span>); i&lt;=<span class="hljs-built_in">bi</span>(n); i++)<span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(i),id+<span class="hljs-built_in">eb</span>(i)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<br><span class="hljs-type">int</span> op,l,r,c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123;<br>cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br><span class="hljs-type">int</span> lb=<span class="hljs-built_in">bi</span>(l),rb=<span class="hljs-built_in">bi</span>(r);<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=r; i++)a[i]+=c;<br><span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(lb),id+<span class="hljs-built_in">eb</span>(lb)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<span class="hljs-comment">//排序，但是有些题会被卡常</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lb+<span class="hljs-number">1</span>; i&lt;=rb<span class="hljs-number">-1</span>; i++)tag[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)a[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=r; i++)a[i]+=c;<br><span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(lb),id+<span class="hljs-built_in">eb</span>(lb)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<br><span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(rb),id+<span class="hljs-built_in">eb</span>(rb)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=r; i++)ans+=a[i]+tag[lb]&lt;c*c;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lb+<span class="hljs-number">1</span>; i&lt;=rb<span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-type">int</span> l=<span class="hljs-built_in">sb</span>(i),r=<span class="hljs-built_in">eb</span>(i);<br><span class="hljs-keyword">if</span>(a[id[l]]+tag[i]&gt;=c*c)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-comment">//二分查找每块里小于c的个数</span><br><span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[id[mid]]+tag[i]&lt;c*c)l=mid;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>ans+=l-<span class="hljs-built_in">sb</span>(i)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)ans+=a[i]+tag[lb]&lt;c*c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=r; i++)ans+=a[i]+tag[rb]&lt;c*c;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ynoi2017-由乃打扑克区间加区间查询">[Ynoi2017]由乃打扑克（区间加，区间查询）</h2><h3 id="题目链接-1"><a href="https://www.luogu.com.cn/problem/P5356">题目链接</a></h3><h3 id="题目描述-1">题目描述</h3><p>给你一个长为 <em>n</em> 的序列 <em>a</em>，需要支持 <em>m</em>次操作，操作有两种：</p><ol type="1"><li>查询区间 [l,r]的第 <em>k</em> 小值。</li><li>区间 [<em>l</em>,<em>r</em>] 加上 <em>k</em>。</li></ol><h3 id="输入格式-1">输入格式</h3><p>一行两个整数 <em>n</em>，<em>m</em>。</p><p>接下来一行 <em>n</em> 个整数， 第 i 个整数表示 a<sub>i</sub>。</p><p>接下来 m<em>m</em> 行，每行四个数<em>opt</em>,<em>l</em>,<em>r</em>,<em>k</em>，其中 <em>opt</em>代表是哪种操作。</p><h3 id="输出格式-1">输出格式</h3><p>对于每个询问输出一个数表示答案，如果无解输出 −1。</p><h3 id="输入输出样例">输入输出样例</h3><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h3 id="思路-1">思路</h3><p>区间加和上题一样，区间查询我们运用二分答案+上面的区间求和来做，二分答案，求区间和，如果有k-1个比答案小的数就是最终答案，我们通过二分来逼近这个答案。这样做之后我们就把区间查询问题转化成了区间求和。</p><p>同样的，我们来算一下块长b</p><p>查询零散块为O(<span class="math inline">\(blogn\)</span>)，先归并零散块再排序可以优化为O(<span class="math inline">\(b+log^2n\)</span>)</p><p>查询整块为O(<span class="math inline">\(logn\frac{n}{b}logb\)</span>)=O(<span class="math inline">\(\frac{n}{b}log^2n\)</span>) <span class="math display">\[b+log^2n+\frac{n}{b}log^2n\ge2\sqrt{n}logn+log^2n\\在b=\frac{n}{b}log^2n时取等，此时b=\sqrt{n}logn\]</span></p><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bi(x) (((x)-1)/block)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sb(x) ((x)*block+1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb(x) min(((x)+1)*block,n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-comment">/*1e4*/</span><span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,block=<span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>;<br>ch=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) s=s*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> s*w;<br>&#125;<br><span class="hljs-comment">//快写</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">10</span>)<span class="hljs-built_in">out</span>(a/<span class="hljs-number">10</span>);<br><span class="hljs-built_in">putchar</span>(a%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-type">int</span> a[N],id[N],tmp[N],e,tag[<span class="hljs-built_in">bi</span>(N)+<span class="hljs-number">10</span>],n,m,buf1[N],buf2[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span> </span>&#123;<br><span class="hljs-type">int</span> lb=<span class="hljs-built_in">bi</span>(l),rb=<span class="hljs-built_in">bi</span>(r);<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=r; i++)a[i]+=c;<br><span class="hljs-comment">/*sort(id+sb(lb),id+eb(lb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);*/</span><br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lb+<span class="hljs-number">1</span>; i&lt;=rb<span class="hljs-number">-1</span>; i++)tag[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)a[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=r; i++)a[i]+=c;<br><br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><br>e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=<span class="hljs-built_in">eb</span>(rb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=<span class="hljs-built_in">eb</span>(rb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><span class="hljs-comment">/*sort(id+sb(lb),id+eb(lb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);</span><br><span class="hljs-comment">sort(id+sb(rb),id+eb(rb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);*/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span> lb=<span class="hljs-built_in">bi</span>(l),rb=<span class="hljs-built_in">bi</span>(r);<br>e=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb);i&lt;=<span class="hljs-built_in">eb</span>(lb);i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) tmp[++ e] = id[i];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*for(int i=sb(lb); i&lt;=eb(lb); i++)if(id[i]&gt;=l&amp;&amp;id[i]&lt;=r)tmp[++e]=id[i];</span><br><span class="hljs-comment">for(int i=sb(rb); i&lt;=eb(rb); i++)if(id[i]&gt;=l&amp;&amp;id[i]&lt;=r)tmp[++e]=id[i];</span><br><span class="hljs-comment">sort(tmp,tmp+e+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);*/</span><br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb);i&lt;=<span class="hljs-built_in">eb</span>(lb);i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb);i&lt;=<span class="hljs-built_in">eb</span>(rb);i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf2[++ e2] = id[i];<br><br><span class="hljs-keyword">while</span>(p1 &lt;= e1 || p2 &lt;= e2) &#123;<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] + tag[lb] &lt; a[buf2[p2]] + tag[rb]) tmp[++ e] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> tmp[++ e] = buf2[p2 ++];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span> </span>&#123;<br><span class="hljs-type">int</span> lb = <span class="hljs-built_in">bi</span>(l), rb = <span class="hljs-built_in">bi</span>(r);<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= lb + <span class="hljs-number">1</span>;i&lt;= rb - <span class="hljs-number">1</span>;i++) &#123;<br><span class="hljs-type">int</span> l = <span class="hljs-built_in">sb</span>(i), r = <span class="hljs-built_in">eb</span>(i);<br><span class="hljs-keyword">if</span>(a[id[l]] + tag[i] &gt;= c) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">while</span>(l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[id[mid]] + tag[i] &lt; c) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans += l - <span class="hljs-built_in">sb</span>(i) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(~e &amp;&amp; a[tmp[<span class="hljs-number">0</span>]] + tag[<span class="hljs-built_in">bi</span>(tmp[<span class="hljs-number">0</span>])] &lt; c) &#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = e;<br><span class="hljs-keyword">while</span>(l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[tmp[mid]] + tag[<span class="hljs-built_in">bi</span>(tmp[mid])] &lt; c) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans += l + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">//scanf(&quot;%d&quot;,&amp;a[i]);</span><br>a[i]=<span class="hljs-built_in">read</span>();<br>id[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">bi</span>(<span class="hljs-number">1</span>); i&lt;=<span class="hljs-built_in">bi</span>(n); i++)<span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(i),id+<span class="hljs-built_in">eb</span>(i)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;=m; k++) &#123;<br><span class="hljs-type">int</span> op,l,r,c;<br>op=<span class="hljs-built_in">read</span>(),l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<span class="hljs-built_in">add</span>(l,r,c);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(c&gt;r-l+<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> ll=<span class="hljs-number">-2e9</span>,rr=<span class="hljs-number">2e9</span>;<br><span class="hljs-built_in">init</span>(l,r);<br><span class="hljs-keyword">while</span>(ll&lt;rr) &#123;<br><span class="hljs-type">int</span> mid=(ll+rr+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(l,r,mid)&lt;c)ll=mid;<br><span class="hljs-keyword">else</span> rr=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ll);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bi(x) (((x)-1)/block)<span class="hljs-comment">//块序号</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sb(x) ((x)*block+1)<span class="hljs-comment">//每块开始位置 strat of block</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb(x) min(((x)+1)*block,n) <span class="hljs-comment">//每块结束位置 end of block</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-comment">/*1e4*/</span><span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,block=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block</span> &#123;<br><span class="hljs-comment">//基本是分块必备了</span><br><br><span class="hljs-type">int</span> id[N],tmp[N],e,tag[<span class="hljs-built_in">bi</span>(N)+<span class="hljs-number">10</span>],buf1[N],buf2[N],a[N],n,m;<br><span class="hljs-built_in">Block</span>() &#123;<br>e=<span class="hljs-number">-1</span>;<br><span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(id));<br><span class="hljs-built_in">memset</span>(tag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(tag));<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(tmp));<br><span class="hljs-built_in">memset</span>(buf1,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf1));<br><span class="hljs-built_in">memset</span>(buf2,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf2));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span> </span>&#123;<br><span class="hljs-type">int</span> lb=<span class="hljs-built_in">bi</span>(l),rb=<span class="hljs-built_in">bi</span>(r);<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=r; i++)a[i]+=c;<br><span class="hljs-comment">/*sort(id+sb(lb),id+eb(lb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);*/</span><br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lb+<span class="hljs-number">1</span>; i&lt;=rb<span class="hljs-number">-1</span>; i++)tag[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l; i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)a[i]+=c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=r; i++)a[i]+=c;<br><br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><br>e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=<span class="hljs-built_in">eb</span>(rb); i++)<br><span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">else</span> buf2[++ e2] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=<span class="hljs-built_in">eb</span>(rb); i++)<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] &lt; a[buf2[p2]]) id[i] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> id[i] = buf2[p2 ++];<br><span class="hljs-comment">/*sort(id+sb(lb),id+eb(lb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);</span><br><span class="hljs-comment">sort(id+sb(rb),id+eb(rb)+1,[&amp;](int x,int y) &#123;</span><br><span class="hljs-comment">return a[x]&lt;a[y];</span><br><span class="hljs-comment">&#125;);*/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span> lb=<span class="hljs-built_in">bi</span>(l),rb=<span class="hljs-built_in">bi</span>(r);<br>e=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(lb==rb) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) tmp[++ e] = id[i];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> e1 = <span class="hljs-number">-1</span>, e2 = <span class="hljs-number">-1</span>, p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(lb); i&lt;=<span class="hljs-built_in">eb</span>(lb); i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf1[++ e1] = id[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">sb</span>(rb); i&lt;=<span class="hljs-built_in">eb</span>(rb); i++) <span class="hljs-keyword">if</span>(id[i] &gt;= l &amp;&amp; id[i] &lt;= r) buf2[++ e2] = id[i];<br><br><span class="hljs-keyword">while</span>(p1 &lt;= e1 || p2 &lt;= e2) &#123;<br><span class="hljs-keyword">if</span>(p2 &gt; e2 || p1 &lt;= e1 &amp;&amp; a[buf1[p1]] + tag[lb] &lt; a[buf2[p2]] + tag[rb]) tmp[++ e] = buf1[p1 ++];<br><span class="hljs-keyword">else</span> tmp[++ e] = buf2[p2 ++];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span> </span>&#123;<br><span class="hljs-type">int</span> lb = <span class="hljs-built_in">bi</span>(l), rb = <span class="hljs-built_in">bi</span>(r);<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= lb + <span class="hljs-number">1</span>; i&lt;= rb - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-type">int</span> l = <span class="hljs-built_in">sb</span>(i), r = <span class="hljs-built_in">eb</span>(i);<br><span class="hljs-keyword">if</span>(a[id[l]] + tag[i] &gt;= c) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">while</span>(l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[id[mid]] + tag[i] &lt; c) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans += l - <span class="hljs-built_in">sb</span>(i) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(~e &amp;&amp; a[tmp[<span class="hljs-number">0</span>]] + tag[<span class="hljs-built_in">bi</span>(tmp[<span class="hljs-number">0</span>])] &lt; c) &#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = e;<br><span class="hljs-keyword">while</span>(l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[tmp[mid]] + tag[<span class="hljs-built_in">bi</span>(tmp[mid])] &lt; c) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans += l + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">find_kth</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(c&gt;r-l+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> ll=<span class="hljs-number">-2e9</span>,rr=<span class="hljs-number">2e9</span>;<br><span class="hljs-built_in">init</span>(l,r);<br><span class="hljs-keyword">while</span>(ll&lt;rr) &#123;<br><span class="hljs-type">int</span> mid=(ll+rr+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(l,r,mid)&lt;c)ll=mid;<br><span class="hljs-keyword">else</span> rr=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ll;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id_sort</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">bi</span>(<span class="hljs-number">1</span>); i&lt;=<span class="hljs-built_in">bi</span>(n); i++)<span class="hljs-built_in">sort</span>(id+<span class="hljs-built_in">sb</span>(i),id+<span class="hljs-built_in">eb</span>(i)+<span class="hljs-number">1</span>,[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br><span class="hljs-keyword">return</span> a[x]&lt;a[y];<br>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>分块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫队算法</title>
    <link href="/2022/04/02/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/04/02/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="引例">引例</h2><p>首先思考这个问题</p><p>给定一个长度为n的序列，求区间[l,r]内出现次数为k的数字种数,询问m次</p><h2 id="思路">思路</h2><h3 id="思路1">思路1</h3><p>首先我们暴力的思考这个问题，枚举区间，时间复杂度O(n*m)</p><h3 id="思路2">思路2</h3><p>这样的复杂度肯定太大，于是我们思考另一种暴力方式</p><p>对一个询问，我们使用l，r(初值为左边界1（1-n应该都可以）)来靠近询问的区间</p><p>例如询问（1，3）将r++,然后将r上的数记录次数，如果缩小区间就r--，将r上的数减少一次次数。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">add</span>(x)&#123;  <span class="hljs-comment">//把x位置的数字加入进来</span><br>    cnt[x]++;<br>    <span class="hljs-keyword">if</span> (cnt[x]==k) ans++;<br>&#125;<br><span class="hljs-built_in">remove</span>(x)&#123;  <span class="hljs-comment">//把x位置的数字移出去</span><br>    cnt[x]--;<br>    <span class="hljs-keyword">if</span> (cnt[x]==k<span class="hljs-number">-1</span>) ans--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">while</span>(l&lt;op[i].l)&#123;ans+=<span class="hljs-built_in">remove</span>(d[l++]);&#125;<br><span class="hljs-keyword">while</span>(l&gt;op[i].l)&#123;ans+=<span class="hljs-built_in">add</span>(d[--l]);&#125;<br><span class="hljs-keyword">while</span>(r&lt;op[i].r)&#123;ans+=<span class="hljs-built_in">add</span>(d[++r]);&#125;<br><span class="hljs-keyword">while</span>(r&gt;op[i].r)&#123;ans+=<span class="hljs-built_in">remove</span>(d[r--]);&#125;<br>ret[op[i].id]=ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样的思路并没有改变复杂度，每次l,r偏移量最大为n，偏移m次，最终复杂度为O(n*m),甚至可能比第一种思路还要慢。</p><h3 id="思路3">思路3</h3><p>继续思路2的想法，我们用l，r表示靠近询问区间。但是我们对询问的区间进行离线处理，进行一个排序，<span class="math inline">\(\sqrt n\)</span>分为一块，块小的在前面，对l处于同一块的区间，我们对r从小到大排序。</p><p>排序代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Query x,Query y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> ((x/block)!=(y/block))<br>        <span class="hljs-keyword">return</span> x.L&lt;y.L;        <span class="hljs-comment">//不同块的时候</span><br>    <span class="hljs-keyword">return</span> x.r&lt;y.r;      <span class="hljs-comment">//同一块的时候</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的复杂度</p><p>l的偏移量最多只有<span class="math inline">\(\sqrtn\)</span>，对于m次查询就是<span class="math inline">\(m*\sqrtn\)</span></p><p>对于同一块，r的总偏移量为n,总共有<span class="math inline">\(\sqrtn\)</span>个区间，所以总共就是<span class="math inline">\(n*\sqrtn\)</span></p><p>两者相加的复杂度就是<span class="math inline">\(O((m+n)*\sqrtn)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs序</title>
    <link href="/2022/04/02/dfs%E5%BA%8F/"/>
    <url>/2022/04/02/dfs%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="定义">定义</h2><p>dfs序是对树进行dfs遍历得到的一个时间戳序列</p><p>dfs的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tot,in[N],out[N];<span class="hljs-comment">//in表示进入节点的时间戳，out表示出节点的时间戳，in可以表示区间的左边界l，out可以表示区间的右边界r</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    in[u]=++tot;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t[x].<span class="hljs-built_in">size</span>();i++)&#123;  <br>        <span class="hljs-type">int</span> v=t[x][i];  <br>        <span class="hljs-built_in">dfs</span>(v);  <br>    &#125; <br>    out[u]=tot;<br>&#125;<br></code></pre></td></tr></table></figure><p>树化成线段举例如下图</p><figure><img src="/2022/04/02/dfs%E5%BA%8F/blog\source\picture\dfs序.png" alt="dfs序"><figcaption aria-hidden="true">dfs序</figcaption></figure><h2 id="应用">应用</h2><p>暂时没学到其他应用，先大体了解这个可以化树为线段的性质。</p><p>注意，节点化为线段之后的序号为in[u]。</p><p>不过既然可以化作线段，那么关于线段的操作都可以做，比如树状数组和线段树以及莫队。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>dfs序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的果实</title>
    <link href="/2022/04/02/%E6%A0%91%E7%9A%84%E6%9E%9C%E5%AE%9E/"/>
    <url>/2022/04/02/%E6%A0%91%E7%9A%84%E6%9E%9C%E5%AE%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>你梦见了一棵树，这是一棵很茂密的树，因此它有很多的分支。</p><p>你注意到这颗树的有 n<em>n</em>个果实，每一棵果实都有自己的编号，且标号为 11的果实在最上面，像是一个根节点，树上的一个果实 u<em>u</em> 到另一个果实v<em>v</em> 的距离，都恰好是一个整数 c<em>c</em> ，因为已经固定好了 11号果实为根节点，所以这棵树的形状已经确定了，你想知道摘下一颗果实，会连带着把它的子树的果实也给摘下来。</p><p>而这个<strong>摘下来所得到的贡献为(数字出现的次数*数字)的平方</strong></p><p>比如2出现了5次，那么贡献即为(2*5)^2(2∗5)2</p><p><strong>数字为两个果实之间的距离即树的边权值，边权值的范围为 c*c*。</strong></p><p>所以你有m组询问，想知道当前询问的果实连带着它的子树果实被摘下来时的贡献是多少。</p><h2 id="输入">输入</h2><p>第11行，三个整数n,m,c<em>n</em>,<em>m</em>,<em>c</em>分别表示树的大小，询问的个数，边权的范围。(1n,m,c )(1≤<em>n</em>,<em>m</em>,<em>c</em>≤100000)</p><p>第2-n2−<em>n</em>行，每行三个整数u,v,vi<em>u</em>,<em>v</em>,<em>v<strong>i<em>表示从u</em>u<em>到v</em>v<em>有一条vi</em>v</strong>i</em>边权的边。</p><p>接下来m<em>m</em>行，每行一个整数表示询问的节点。</p><h2 id="输出">输出</h2><p>输出m<em>m</em>行，每行一个整数代表子树的权值大小。(保证不会超过longlong)</p><h2 id="样例输入">样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">9</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">10</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">11</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br><span class="hljs-number">10</span><br><span class="hljs-number">6</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="样例输出">样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">158<br>109<br>0<br>0<br>547<br>158<br></code></pre></td></tr></table></figure><h2 id="思路">思路</h2><p>比赛的时候基本啥算法没想，感觉建一个树，暴力记一下每个子树的贡献时间复杂度也可以，结果爆内存了。。。</p><p>然后看题解</p><p>首先是dfs序把树变成线性，用区间表示一个子树，具体可以参考这个博客https://blog.csdn.net/qq_37275680/article/details/82793691我尝试自己再总结一遍</p><p>然后是对区间求贡献，可以用线段树，复杂度是O(nlogn)，也可以用莫队(又是我没学过的算法)，复杂度O(nsqrt(n))可以参考https://blog.csdn.net/ThinFatty/article/details/72581276?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1，我自己也会尝试总结一遍</p><p>然后贴上代码，因为没找到比赛补题的地方，不知道能不能过，就只过了样例意思意思吧</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> block;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sec</span> &#123;<br><span class="hljs-type">int</span> l,r,id;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> Sec&amp;b)<span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">if</span>((l/block)!=(b.l/block))<span class="hljs-keyword">return</span> l&lt;b.l;<br><span class="hljs-keyword">return</span> r&lt;b.r;<br>&#125;<br>&#125; sec[N],op[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;t[N];<br><span class="hljs-type">int</span> tot,cnt[N],val[N],d[N],id[N],ret[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>sec[u].l=++tot;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;t[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-built_in">dfs</span>(t[u][i]);<br>&#125;<br>sec[u].r=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>cnt[x]++;<br><span class="hljs-keyword">return</span> (cnt[x]*x)*(cnt[x]*x)-(cnt[x]<span class="hljs-number">-1</span>)*x*(cnt[x]<span class="hljs-number">-1</span>)*x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>cnt[x]--;<br><span class="hljs-keyword">return</span> (cnt[x]*x)*(cnt[x]*x)-(cnt[x]+<span class="hljs-number">1</span>)*x*(cnt[x]+<span class="hljs-number">1</span>)*x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,m,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;c);block=<span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);<br>t[u].<span class="hljs-built_in">push_back</span>(v);<br>val[v]=w;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//dfs序 化树为线段</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>d[sec[i].l]=val[i];<span class="hljs-comment">//化边权为点权</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u;<br>cin&gt;&gt;u;<br>op[i].l=sec[u].l+<span class="hljs-number">1</span>;<span class="hljs-comment">//很关键 要计算的是子树，所以要去掉自己的点</span><br>op[i].r=sec[u].r; <br>op[i].id=i;<br>&#125;<br><span class="hljs-built_in">sort</span>(op+<span class="hljs-number">1</span>,op+<span class="hljs-number">1</span>+m);<span class="hljs-comment">//离线处理区间查询操作</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//莫队求区间贡献</span><br><span class="hljs-keyword">while</span>(l&lt;op[i].l)&#123;ans+=<span class="hljs-built_in">remove</span>(d[l]);l++;&#125;<br><span class="hljs-keyword">while</span>(l&gt;op[i].l)&#123;l--;ans+=<span class="hljs-built_in">add</span>(d[l]);&#125;<br><span class="hljs-keyword">while</span>(r&lt;op[i].r)&#123;r++;ans+=<span class="hljs-built_in">add</span>(d[r]);&#125;<br><span class="hljs-keyword">while</span>(r&gt;op[i].r)&#123;ans+=<span class="hljs-built_in">remove</span>(d[r]);r--;&#125;<br>ret[op[i].id]=ans;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)cout&lt;&lt;ret[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs序</tag>
      
      <tag>莫队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树模板</title>
    <link href="/2022/03/27/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/03/27/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树模板-区间求和为例">线段树模板-区间求和为例</h1><h2 id="建树">建树</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l==r) &#123;<br>t[x]=a[l];<span class="hljs-comment">//将线段上的值转换到树上 根据节点属性的设置来设置此处内容</span><br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(ls,l,mid);<br><span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(x);<span class="hljs-comment">//向上传递状态</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间修改">区间修改</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;<br>lazy[x]+=v;<span class="hljs-comment">//懒惰标记 *只打标记 不向下传递*</span><br>t[x]+=v*(r-l+<span class="hljs-number">1</span>);<span class="hljs-comment">//区间和操作 *只进行此次操作*</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">pushdown</span>(x,r-l+<span class="hljs-number">1</span>);<span class="hljs-comment">//向下传递 并清空自身节点 *计算子节点标记贡献*</span><br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)<span class="hljs-built_in">update</span>(ls,l,mid,L,R,v);<br><span class="hljs-keyword">if</span>(mid&lt;R) <span class="hljs-built_in">update</span>(rs,mid+<span class="hljs-number">1</span>,r,L,R,v);<br><span class="hljs-built_in">pushup</span>(x);<span class="hljs-comment">//向上更新状态</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间查询">区间查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;<br><span class="hljs-keyword">return</span> t[x];<br>&#125;<br><span class="hljs-built_in">pushdown</span>(x);<span class="hljs-comment">//向下传递 并清空自身节点 *计算子节点标记贡献*</span><br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)ans+=<span class="hljs-built_in">query</span>(ls,l,mid,L,R);<span class="hljs-comment">//计算子节点和</span><br><span class="hljs-keyword">if</span>(mid&lt;R)ans+=<span class="hljs-built_in">query</span>(rs,mid+<span class="hljs-number">1</span>,r,L,R);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pushdown函数">pushdown函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(lazy[x]) &#123;<br>lazy[ls]+=lazy[x];<span class="hljs-comment">//向下传递标记</span><br>lazy[rs]+=lazy[x];<br>tr[ls]+=lazy[x]*len/<span class="hljs-number">2</span>;<span class="hljs-comment">//*计算子节点标记贡献*</span><br>tr[rs]+=lazy[x]*len/<span class="hljs-number">2</span>;<br>lazy[x]=<span class="hljs-number">0</span>;<span class="hljs-comment">//清空自身节点</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>看错题-线段树</title>
    <link href="/2022/03/27/%E7%9C%8B%E9%94%99%E9%A2%98/"/>
    <url>/2022/03/27/%E7%9C%8B%E9%94%99%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定一颗线段树，每次区间加一个x，如果每次在线段树区间加操作做完后，依次选一个叶子节点进入，然后一直走到根节点，问最后得到的期望值是多少。</p><p>小Y同学为了让题目更简单，对于n个整数，n是一个2^x2<em>x</em>的整数，来保证这个线段树是一棵满二叉树。</p><p>他现在想问你，每次给一段区间加上一个整数（每次操作对后续有影响），然后依次在线段树中选一个叶子节点，一直走到根节点，将一路经过的节点权值累加，问把每一个叶子节点选择一遍后的全部的总和是多少。</p><h2 id="input">Input</h2><p>第一行整数 <em>n</em>,<em>m</em>,表示线段树维护的原序列的长度，询问次数。</p><p>第二行 n<em>(1≤</em>n<em>≤217</em>) 个数，表示原序列。</p><p>接下来 m(1≤<em>m</em>≤100000) 行，每行三个数l,r,x<em>l</em>,<em>r</em>,<em>x</em>表示对区间[l,r][<em>l</em>,<em>r</em>] 加上 x<em>x</em></p><h2 id="output">Output</h2><p>共 m<em>m</em> 行，表示查询的权值和。</p><h2 id="sample-input">Sample Input</h2><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="sample-output">Sample Output</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">720<br>960<br></code></pre></td></tr></table></figure><h2 id="思路">思路</h2><p>区间修改，区间求和，但是这题不用写查询，因为从所有叶子节点到根节点的链的和为根节点的权值*(2*n-1)</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls 2*x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs 2*x+1</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[N],tr[N&lt;&lt;<span class="hljs-number">2</span>],lazy[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l==r) &#123;<br>tr[x]=a[l];<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(ls,l,mid);<br><span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>tr[x]=tr[ls]+tr[rs];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(lazy[x]) &#123;<br>lazy[ls]+=lazy[x];<br>lazy[rs]+=lazy[x];<br>tr[ls]+=lazy[x]*len/<span class="hljs-number">2</span>;<br>tr[rs]+=lazy[x]*len/<span class="hljs-number">2</span>;<br>lazy[x]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;<br>lazy[x]+=v;<br>tr[x]+=v*(r-l+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">pushdown</span>(x,r-l+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)<span class="hljs-built_in">update</span>(ls,l,mid,L,R,v);<br><span class="hljs-keyword">if</span>(mid&lt;R) <span class="hljs-built_in">update</span>(rs,mid+<span class="hljs-number">1</span>,r,L,R,v);<br>tr[x]=tr[ls]+tr[rs];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]) ;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">while</span>(m--) &#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l,r,v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;l,&amp;r,&amp;v);<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r,v);<br><span class="hljs-comment">//cout&lt;&lt;tr[10]&lt;&lt;endl;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,tr[<span class="hljs-number">1</span>]*(<span class="hljs-number">1ll</span>*n*<span class="hljs-number">2</span><span class="hljs-number">-1</span>));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*8 2</span><br><span class="hljs-comment">1 2 3 4 5 6 7 8</span><br><span class="hljs-comment">1 8 2</span><br><span class="hljs-comment">1 3 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“Z”型矩阵</title>
    <link href="/2022/03/24/%E2%80%9CZ%E2%80%9D%E5%9E%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/03/24/%E2%80%9CZ%E2%80%9D%E5%9E%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题意">题意：</h2><p>对于一个只包含 <code>.</code> 和 <code>z</code>的矩阵，当以下条件满足时：</p><ol type="1"><li>该矩阵的行数列数相等。</li><li>该矩阵的第一行与最后一行的字符全是 <code>z</code>。</li><li>该矩阵从右上角到左下角的对角线上的字符全是 <code>z</code>。</li></ol><p>我们称其为 <code>Z</code> 矩阵。</p><p>现在给定一个 n×mn×m 的矩阵，请你计算它有多少个子矩阵是 <code>Z</code>矩阵。</p><h3 id="输入格式">输入格式</h3><p>第一行两个整数 nn , mm 分别表示矩阵的行数和列数(1≤n,m≤3×103)(1≤n,m≤3×103)。</p><p>接下来 nn 行, 每行包含 mm 个字符, 表示该矩阵。</p><h3 id="输出格式">输出格式</h3><p>输出一行一个整数表示 <code>Z</code> 矩阵的数量。</p><h3 id="样例输入">样例输入</h3><figure class="highlight erlang"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">4</span> <span class="hljs-number">4</span><br>zzzz<br>z.z.<br>.zz.<br>zzzz<br></code></pre></td></tr></table></figure><h3 id="样例输出">样例输出</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">14<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>好题，但不会！看题解学的，具体过程参考这位大佬的知乎。</p><p>https://zhuanlan.zhihu.com/p/486600382</p><p>简单说一下就是遍历对角线，在对角线上建树状数组，将每个连续的“z”看作一段，离线维护线段上每点的左右“z”各能到达的最远位置。然后遍历这个线段，维护每个点能到达后续点的的贡献，凡是能到达的后续点都可以利用到此点的贡献。(看不懂就看原dalao的知乎就完了)</p><p>然后贴出我的代码，虽然和大佬的代码基本一样，但是因为原代码的树状数组部分没给，我的写法与dalao还有一丝丝不同。</p><h2 id="代码">代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g[N][N],L[N][N],R[N][N],t[N];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;line[<span class="hljs-number">2</span>*N];<br>vector&lt;<span class="hljs-type">int</span>&gt;del[<span class="hljs-number">2</span>*N];<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-type">int</span> s1=<span class="hljs-number">0</span>,s2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(L&gt;<span class="hljs-number">0</span>)&#123;<br>s1+=t[L];<br>L-=<span class="hljs-built_in">lowbit</span>(L);<br>&#125;<br><span class="hljs-keyword">while</span>(R&gt;<span class="hljs-number">0</span>)&#123;<br>s2+=t[R];<br>R-=<span class="hljs-built_in">lowbit</span>(R);<br>&#125;<br><span class="hljs-keyword">return</span> s2-s1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span></span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;=cnt)&#123;<br>t[x]+=w;<br>x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//cout&lt;&lt;endl;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br><span class="hljs-type">int</span> L=line[i].first,R=line[i].second;<br>ans+=<span class="hljs-built_in">query</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,i-R+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>,i);<br><span class="hljs-keyword">if</span>(L&gt;<span class="hljs-number">1</span>)<span class="hljs-built_in">add</span>(i,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;L&lt;&lt;&#x27; &#x27;&lt;&lt;R&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(L&gt;<span class="hljs-number">1</span>)del[<span class="hljs-built_in">min</span>(cnt,i+L<span class="hljs-number">-1</span>)].<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:del[i])<span class="hljs-built_in">add</span>(x,<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(t,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(t));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)del[i].<span class="hljs-built_in">clear</span>();<br>cnt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-type">char</span> c;<br>cin&gt;&gt;c;<br>g[i][j]=c==<span class="hljs-string">&#x27;z&#x27;</span>;<br>ans+=c==<span class="hljs-string">&#x27;z&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(g[i][j])L[i][j]=L[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(g[i][j])R[i][j]=R[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">2</span>;d&lt;=n+m;d++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,d-m);i&lt;=<span class="hljs-built_in">min</span>(n,d<span class="hljs-number">-1</span>);i++)&#123;<br><span class="hljs-type">int</span> j=d-i;<br><span class="hljs-keyword">if</span>(!g[i][j])&#123;<br><span class="hljs-keyword">if</span>(cnt)<span class="hljs-built_in">solve</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>line[++cnt]=&#123;L[i][j],R[i][j]&#125;;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt)<span class="hljs-built_in">solve</span>();<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>离线</tag>
      
      <tag>代码源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求质因子模板</title>
    <link href="/2022/03/23/%E6%B1%82%E8%B4%A8%E5%9B%A0%E5%AD%90%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/03/23/%E6%B1%82%E8%B4%A8%E5%9B%A0%E5%AD%90%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>复杂度大概O(nlnn)吧</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;N; i++) &#123;<br><span class="hljs-keyword">if</span>(tt[i].<span class="hljs-built_in">size</span>())<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;N; j+=i) &#123;<br><span class="hljs-type">int</span> t=j,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(t%i==<span class="hljs-number">0</span>)t/=i,cnt++;<br>tt[j].<span class="hljs-built_in">push_back</span>(&#123;i,cnt&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>质因子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数模板</title>
    <link href="/2022/03/23/%E7%BB%84%E5%90%88%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/03/23/%E7%BB%84%E5%90%88%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>复杂度O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(b) &#123;<br><span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)c=(<span class="hljs-number">1ll</span>*c*a)%mod;<br>a=<span class="hljs-number">1ll</span>*a*a%mod;<br>b&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;m||m&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> fac[n]*infac[n-m]%mod*infac[m]%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>fac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;N; i++)fac[i]=<span class="hljs-number">1ll</span>*fac[i<span class="hljs-number">-1</span>]*i%mod;<br>infac[N<span class="hljs-number">-1</span>]=<span class="hljs-built_in">Pow</span>(fac[N<span class="hljs-number">-1</span>],mod<span class="hljs-number">-2</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">1</span>; i--)infac[i<span class="hljs-number">-1</span>]=<span class="hljs-number">1ll</span>*infac[i]*i%mod;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串处理技巧</title>
    <link href="/2022/03/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/03/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串处理常用技巧">字符串处理常用技巧</h1><h3 id="find以及其他查找函数">1、find()以及其他查找函数</h3><h6 id="find">find()</h6><p>int find(char c, int pos = 0)const;//从pos开始查找字符c在当前字符串的位置 int find(const char <em>s,int pos = 0) const;//从pos开始查找字符串s在当前串中的位置 int find(constchar </em>s, int pos, int n)const;//从pos开始查找字符串s中前n个字符在当前串中的位置 int find(conststring &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置//查找成功时返回所在位置，失败返回<strong>string::npos</strong>的值</p><h6 id="rfind">rfind()</h6><p>int rfind(char c, int pos = npos)const;//从pos开始从后向前查找字符c在当前串中的位置 int rfind(const char<em>s, int pos = npos) const; int rfind(const char </em>s, int pos, intn = npos) const; int rfind(const string &amp;s,int pos = npos) const;//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回<strong>string::npos</strong>的值</p><h6 id="find_first_not_of">find_first_not_of()</h6><p>int find_first_not_of(char c, int pos = 0) const; intfind_first_not_of(const char <em>s, int pos = 0) const; intfind_first_not_of(const char </em>s, int pos,int n) const; intfind_first_not_of(const string &amp;s,int pos = 0) const;//从当前串中查找第一个不在串s中的字符出现的位置，失败返回<strong>string::npos</strong></p><h6 id="find_last_not_of">find_last_not_of()</h6><p>int find_last_not_of(char c, int pos = npos) const; intfind_last_not_of(const char <em>s, int pos = npos) const; intfind_last_not_of(const char </em>s, int pos, int n) const; intfind_last_not_of(const string &amp;s,int pos = npos) const;</p><p>//从当前串从后往前查找第一个不在串s中的字符出现的位置，失败则返回<strong>string::npos</strong></p><h3 id="c_str">2、c_str()</h3><p>可以将string转换为*char类型</p><h3 id="更改内容">3、更改内容</h3><h6 id="substrint-stint-len">substr(int st,int len)</h6><p>可以返回st开始len个字符的字符串</p><h6 id="s">+s</h6><p>在首或尾添加字符串</p><h6 id="assign可以实现更灵活的赋值">assign()//可以实现更灵活的赋值</h6><p>s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给s</p><p>s.assign(“nico”,5);//把'n' ‘I' ‘c' ‘o' ‘/0'赋给字符串s.assign(5,'x');//把五个x赋给字符串</p><h6 id="append">append()</h6><p>s.append(str,1,3);//不解释了 同前面的函数参数assign的解释s.append(str,2,string::npos)//不解释了 s.append(“nico”,5);s.append(5,'x');</p><h6 id="insert在某个位置插入字符串">insert()//在某个位置插入字符串</h6><p>s.insert(0,”my name”);在0处插入字符串 s.insert(1,str);</p><p>string &amp;insert(int p0, const char <em>s); string &amp;insert(intp0, const char </em>s, int n); string &amp;insert(int p0,const string&amp;s); string &amp;insert(int p0,const string &amp;s, int pos, int n);//前4个函数在p0位置插入字符串s中pos开始的前n个字符 string&amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c iteratorinsert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置void insert(iterator it, const_iterator first, const_iteratorlast);//在it处插入[first，last）之间的字符 void insert(iterator it, intn, char c);//在it处插入n个字符c</p><p><strong>insert()不支持插入单个字符！！</strong></p><p>为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_typeindex,size_type num,chart c)和insert(iterator pos,size_type num,chartc)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,'j');这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,'j')！</p><h6 id="erase去除字符串">erase()//去除字符串</h6><p>s.erase(13);//从索引13开始往后全删除s.erase(7,5);//从索引7开始往后删5个</p><p>iterator erase(iterator first, iteratorlast);//删除[first，last）之间的所有字符，返回删除后迭代器的位置iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置string &amp;erase(int pos = 0, int n =npos);//删除pos开始的n个字符，返回修改后的字符串</p><h6 id="replace替换字符串">replace()//替换字符串</h6><p>s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_string</p><p>string &amp;replace(int p0, int n0,const char<em>s);//删除从p0开始的n0个字符，然后在p0处插入串s string&amp;replace(int p0, int n0,const char </em>s, intn);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符 string&amp;replace(int p0, int n0,const string&amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s string&amp;replace(int p0, int n0,const string &amp;s, int pos, intn);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符 string&amp;replace(int p0, int n0,int n, charc);//删除p0开始的n0个字符，然后在p0处插入n个字符c string&amp;replace(iterator first0, iterator last0,const char<em>s);//把[first0，last0）之间的部分替换为字符串s string&amp;replace(iterator first0, iterator last0,const char </em>s, intn);//把[first0，last0）之间的部分替换为s的前n个字符 string&amp;replace(iterator first0, iterator last0,const string&amp;s);//把[first0，last0）之间的部分替换为串s string&amp;replace(iterator first0, iterator last0,int n, charc);//把[first0，last0）之间的部分替换为n个字符c string&amp;replace(iterator first0, iterator last0,const_iterator first,const_iteratorlast);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p><h5 id="以上内容大部分引自httpsblog.csdn.netfdqw_spharticledetails54233971-c中的string常用函数用法总结">以上内容大部分引自https://blog.csdn.net/fdqw_sph/article/details/54233971《c++中的string常用函数用法总结》</h5><h3 id="sscanf">4、sscanf()</h3><p><strong>int sscanf(const char *str, const char *format,...)</strong></p><p><strong>例题：L2-012关于堆的判断</strong>https://pintia.cn/problem-sets/994805046380707840/problems/994805064676261888</p><p>使用例子：sscanf(s.c_str(),"%d is %s %s of%d",&amp;a,smp1,smp2,&amp;b);</p><h3 id="cout输出格式控制">5、cout输出格式控制</h3><h4 id="控制符控制输出格式">(1)控制符控制输出格式</h4><h5 id="setbasen-设置整数的基数n只能是81016三者之一">setbase(n)设置整数的基数(n只能是8，10，16三者之一)</h5><h5 id="setfillc-设置填充字符cc可以是字符常量或字符串变量">setfill(c)设置填充字符c，c可以是字符常量或<strong><em>字符串变量</em></strong></h5><h5 id="setpercisionn-设置实数精度为n位在以一般十进制小数形式输入时n表示有效数字在以fixed固定小数位数形式和scientific指数形式输出时n为小数位数">setpercision(n)设置实数精度为n位。在以一般十进制小数形式输入时，n表示有效数字。在以fixed(固定小数位数)形式和scientific(指数)形式输出时，n为小数位数。</h5><h5 id="setwn-设置实数的精度为n位">setw(n) 设置实数的精度为n位</h5><h5 id="setiosflagsiosshowbase-输出时显示进制指示符0表示八进制0x或0x表示十六进制"><strong>setiosflags</strong>(ios::showbase)输出时显示进制指示符(0表示八进制，0x或0X表示十六进制)</h5><h5 id="setiosflagsiosfixed-设置浮点数以固定的小数位数显示">setiosflags(ios::fixed)设置浮点数以固定的小数位数显示</h5><h5 id="setiosflagsiosscientific-设置浮点数以科学计数法显示">setiosflags(ios::scientific)设置浮点数以科学计数法显示</h5><h5 id="setiosflagsiosleft-数据左对齐">setiosflags(ios::left)数据左对齐</h5><h5 id="setiosflagsiosright-数据右对齐">setiosflags(ios::right)数据右对齐</h5><h5 id="setiosflagsiosskipws-忽略前导零">setiosflags(ios::skipws)忽略前导零</h5><h4 id="流成员函数控制输出格式">(2)流成员函数控制输出格式</h4><p>同上比较</p><h5 id="percisionnsetpercisionn">percision(n)=setpercision(n)</h5><h5 id="widthnsetwn">width(n)=setw(n)</h5><h5 id="fillcsetfillc">fill(c)=setfill(c)</h5><h5 id="setfsetioflags">setf()=setioflags()</h5>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2022/03/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="区间信息维护查询">区间信息维护查询</h1><h2 id="一二叉索引树树状数组binary-indexed-treebit">一、二叉索引树(树状数组)（BinaryIndexed Tree,BIT)</h2><h3 id="bit支持两种操作">BIT支持两种操作</h3><h6 id="updatex修改单点值">1.update(x):修改<code>单点</code>值</h6><h6 id="querylr查询lr区间和">2.query(L,R)：查询(L,R)区间和</h6><h3 id="实现方式">实现方式：</h3><p>首先我们介绍一下lowbit(x)</p><p>lowbit(x)表示x的二进制表达式中<code>最右边的1所对应的值</code></p><p>程序实现为lowbit(x)={return x&amp;(-x)}</p><p>原理就是计算机的整数用补码表示，所以<code>-x就是x按位取反，末尾加1</code></p><figure><img src="/2022/03/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/bit示意.png" alt="bit示意"><figcaption aria-hidden="true">bit示意</figcaption></figure><p>上图就是典型的BIT</p><p><strong>通过观察我们发现对于节点i,如果i是右儿子,i的父节点为i-lowbit(i),如果i是左儿子,i的父节点为i+lowbit(i).</strong></p><p>然后我们构造一个辅助数组C</p><p><strong>C<sub>i</sub>=A<sub>i-lowbit(i)+1</sub>+A<sub>i-lowbit(i)+1</sub>+...+A<sub>i</sub></strong></p><p><strong>即C<sub>i</sub>为区间[i-lowbit(i)+1,i]的和(上图的长方形块)</strong></p><p>有了这些准备后我们就要开始思考如何进行add和query的操作</p><h3 id="querylr">query(L,R):</h3><p>根据前缀和的思路，我们想到可以分别求出前缀和S[R]和S[L]得到query()的值</p><p><u>以S[L]为例</u>，L以二进制表示，则可以表示为以2为底的幂的和</p><p>所以S[L]=C<sub>a</sub>+C<sub>b</sub>+...+C<sub>z</sub></p><p>要实现这一操作，就要从L开始将S[L],S[L-lowbit(L)]...加入S[L]，直到L==0</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>        ret+=a[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="updatex">update(x):</h3><p>对单一值更新之后，要对包含x的C<sub>i</sub>都进行更新</p><p>实现操作，要从x向上，直到x&gt;n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        C[x]++;<span class="hljs-comment">//更新</span><br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题-ping-pong">例题 Ping pong</h2><p><a href="https://vjudge.net/problem/UVALive-4329">UVALive -4329</a></p><p>首先，选手的位置不能改变。而对于某个选手i，假设他为裁判，此时在他之前比他小的有c<sub>i</sub>个,在他之后比他小的有d<sub>i</sub>个，那么i选手做裁判的情况就有c<sub>i</sub><em>(n-i-d<sub>i</sub>)+(i-c<sub>i</sub>-1)</em>d<sub>i</sub></p><p>问题转换为求c<sub>i</sub>和d<sub>i</sub></p><p>由小到大遍历1-n，每移动一位就在x[a[i]]++,并求x[a[i]]的前缀和，这是一个经典的BIT问题</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100100</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N],d[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x) &#123;<br>ret+=b[x];<br>x-=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;=N<span class="hljs-number">-1</span>) &#123;<br>b[x]+=d;<br>x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--) &#123;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-built_in">add</span>(a[i],<span class="hljs-number">1</span>);<br>c[i]=<span class="hljs-built_in">sum</span>(a[i]<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//printf(&quot;%d &quot;,c[i]);</span><br>&#125;<br><span class="hljs-comment">//printf(&quot;\n&quot;);</span><br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-built_in">add</span>(a[i],<span class="hljs-number">1</span>);<br>d[i]=<span class="hljs-built_in">sum</span>(a[i]<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//printf(&quot;%d &quot;,d[i]);</span><br>&#125;<br><span class="hljs-comment">//printf(&quot;\n&quot;);</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>ret+=c[i]*(n-i-d[i])+(i-c[i]<span class="hljs-number">-1</span>)*d[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ret);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>BIT本质上还是前缀和，他通过lowbit将前缀和数组拆分，从而使修改的复杂度从O(n)降到O(logn)。从而使动态的区间问题的整体复杂度降至O(nlogn)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>区间操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度算法-面向对象</title>
    <link href="/2022/03/21/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/03/21/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度算法-面向对象">高精度算法-面向对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>string s;<br><span class="hljs-type">int</span> num[<span class="hljs-number">1100</span>],len;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">(B)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(B)</span></span>;<br><span class="hljs-built_in">B</span>() &#123;<br>s=<span class="hljs-string">&quot;&quot;</span>;<br>len=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(num));<br>&#125;<br><span class="hljs-built_in">B</span>(string a) &#123;<br>s=a;<br>len=s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)num[i]=s[len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;=(<span class="hljs-type">const</span> B&amp; a) &#123;<br><span class="hljs-keyword">if</span>(len&gt;a.len)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(len==a.len)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span>(num[i]&gt;a.num[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i]&lt;a.num[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>B&amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> B&amp; a) &#123;<br><span class="hljs-keyword">this</span>-&gt;len=a.len;<br><span class="hljs-keyword">this</span>-&gt;s=a.s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)<span class="hljs-keyword">this</span>-&gt;num[i]=a.num[i];<br><span class="hljs-keyword">return</span>*<span class="hljs-keyword">this</span>;<br>&#125;<br>B <span class="hljs-keyword">operator</span> +(B b) &#123;<br>B tmp;<br>tmp.len=<span class="hljs-built_in">max</span>(len,b.len);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">max</span>(len,b.len); i++) &#123;<br>tmp.num[i]+=b.num[i]+num[i];<br>tmp.num[i+<span class="hljs-number">1</span>]+=tmp.num[i]/<span class="hljs-number">10</span>;<br>tmp.num[i]%=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(tmp.num[tmp.len]&gt;<span class="hljs-number">0</span>)tmp.len++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>B <span class="hljs-keyword">operator</span> -(B b) &#123;<br>B tmp;<br>tmp.len=<span class="hljs-built_in">max</span>(len,b.len);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp.len; i++) &#123;<br>tmp.num[i]=num[i]-b.num[i];<br><span class="hljs-keyword">if</span>(tmp.num[i]&lt;<span class="hljs-number">0</span>) &#123;<br>tmp.num[i+<span class="hljs-number">1</span>]--;<br>tmp.num[i]+=<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(tmp.num[tmp.len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;tmp.len&gt;<span class="hljs-number">1</span>)tmp.len--;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>B <span class="hljs-keyword">operator</span> *(B b) &#123;<br>B tmp;<br>tmp.len=len+b.len+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;b.len; j++) &#123;<br>tmp.num[i+j]+=num[i]*b.num[j];<br>tmp.num[i+j+<span class="hljs-number">1</span>]+=tmp.num[i+j]/<span class="hljs-number">10</span>;<br>tmp.num[i+j]%=<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(tmp.num[tmp.len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;tmp.len&gt;<span class="hljs-number">1</span>)tmp.len--;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>B <span class="hljs-keyword">operator</span> /(B b) &#123;<br>B tmp,<span class="hljs-built_in">ans</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-function">B <span class="hljs-title">one</span><span class="hljs-params">(<span class="hljs-string">&quot;0&quot;</span>)</span></span>;<br>tmp.len=len;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)tmp.num[i]=num[i];<br><span class="hljs-type">int</span> diff=len-b.len;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tmp.len<span class="hljs-number">-1</span>; i&gt;=b.len<span class="hljs-number">-1</span>; i--) &#123;<br>B t;<br>t.len=b.len;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>-b.len; j&lt;=i; j++)&#123;<br>t.num[j-diff]=tmp.num[j];<br>&#125;<br><span class="hljs-keyword">while</span>(t&gt;=b) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>-b.len; j&lt;=i; j++) &#123;<br>tmp.num[j]-=b.num[j-diff];<br><span class="hljs-keyword">if</span>(tmp.num[j]&lt;<span class="hljs-number">0</span>)&#123;<br>tmp.num[j]+=<span class="hljs-number">10</span>;<br>tmp.num[j+<span class="hljs-number">1</span>]--;<br>&#125;<br>t.num[j-diff]=tmp.num[j];<br>&#125;<br>one.num[i-b.len+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>one.len=i-b.len+<span class="hljs-number">2</span>;<br>ans=ans+one;<br>&#125;<br>one.num[i-b.len+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>diff--;<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;tmp.num[i]&gt;<span class="hljs-number">0</span>)tmp.num[i<span class="hljs-number">-1</span>]+=tmp.num[i]*<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">(B a)</span> </span>&#123;<br>cin&gt;&gt;a.s;<br>a.len=a.s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=a.len; i--) &#123;<br>a.num[i]=a.s[a.len-i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">const</span> B a)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>cout&lt;&lt;a.num[i];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//input(a);</span><br><span class="hljs-function">B <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;1816324242342&quot;</span>)</span></span>;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;233333&quot;</span>)</span></span>;<br>B c=a/b;<br><span class="hljs-built_in">output</span>(c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>那就别担心了-PTA补题</title>
    <link href="/2022/03/21/%E2%80%9D%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86-PTA%E8%A1%A5%E9%A2%98%E2%80%9C/"/>
    <url>/2022/03/21/%E2%80%9D%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86-PTA%E8%A1%A5%E9%A2%98%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="那就别担心了-pta-l3">那就别担心了 PTA L3</h1><h2 id="常规dfs">常规dfs</h2><p>比赛的时候题意没搞清楚，写了个dfs结果拿了18分就寄了。大概就是问起点到终点一共有几个不同走法，然后问是否从起点开始的所有路径都只能通往终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">550</span>;<br><span class="hljs-type">int</span> cnt[N],vis[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;t[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>vis[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(cnt[u])<span class="hljs-keyword">return</span> cnt[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:t[u])&#123;<br>cnt[u]+=<span class="hljs-built_in">dfs</span>(v);<br>&#125;<br><span class="hljs-keyword">return</span> cnt[u];<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>t[u].<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><span class="hljs-type">int</span> st,ed;<br>cin&gt;&gt;st&gt;&gt;ed;<br>cnt[ed]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(st);<br>cout&lt;&lt;cnt[st]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>((vis[i]&amp;&amp;cnt[i]==<span class="hljs-number">0</span>))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/03/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><strong>背包问题</strong></h1><h2 id="p1048-noip2005-普及组-采药">P1048 [NOIP2005 普及组] 采药</h2><h2 id="题目描述">题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h2 id="输入格式">输入格式</h2><p>第一行有 2 个整数 T（1≤T≤1000）和M（1≤<em>M</em>≤100），用一个空格隔开，<em>T</em>代表总共能够用来采药的时间，<em>M</em> 代表山洞里的草药的数目。</p><p>接下来的 <em>M</em> 行每行包括两个在 1 到 100之间（包括 1 和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h2 id="输出格式">输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p><h2 id="输入输出样例">输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">70 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">71 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">69 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="说明提示">说明/提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 30% 的数据 <em>M</em>≤10；</li><li>对于全部的数据 <em>M</em>≤100。</li></ul><h3 id="思路部分">思路部分</h3><p>想了一下dfs至少能a掉30%的数据，但这不是我们的本意，本意当然是想到dp的做法</p><p>抽象一下题意，我们要做的是求在n个草药中选择，使容量为W的背包获得的价值最大</p><p>因此我们设dp[i][j]表示容量为j的选择前i个草药能获得的最大价值，以此可以表示最终答案的状态</p><p>要求出最终答案，我们要解决最终答案的子问题</p><p><span class="math display">\[dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])\]</span></p><h5 id="优化空间复杂度">优化空间复杂度</h5><p>我们发现，我们在状态转移时并没有利用i的，换言之，要求dp[i][j]，我们不关心前i个草药怎么选，我们只要知道容量小的背包的最优解即可完成状态的转移。因此可以只设dp[j]，表示容量为j的背包的最优价值。</p><h6 id="思考一下为什么要从后往前遍历">思考一下，为什么要从后往前遍历</h6><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">10000010</span>];<br><span class="hljs-type">int</span> w[<span class="hljs-number">10010</span>],v[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,t;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]) ;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n;i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=t; j&gt;=w[i]; j--) &#123;<br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-w[i]]+<span class="hljs-number">1ll</span>*v[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,dp[t]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="p1616-疯狂的采药">P1616 疯狂的采药</h1><h2 id="题目描述-1">题目描述</h2><p>LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是 LiYuxiang，你能完成这个任务吗？</p><p>此题和原题的不同点：</p><ol type="1"><li><p>每种草药可以无限制地疯狂采摘。</p></li><li><p>药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p></li></ol><h2 id="输入格式-1">输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 <em>t</em>和代表山洞里的草药的数目 <em>m</em>。</p><p>第 2 到第(<em>m</em>+1) 行，每行两个整数，第(<em>i</em>+1) 行的整数a<sub>i</sub>, b<sub>i</sub> 分别表示采摘第 i种草药的时间和该草药的价值。</p><h2 id="输出格式-1">输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h2 id="输入输出样例-1">输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">70 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">71 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">69 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">140<br></code></pre></td></tr></table></figure><h2 id="说明提示-1">说明/提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><ul><li><p>对于 30% 的数据，保证m≤10<sup>3</sup> 。</p></li><li><p>对于 100% 的数据，保证1≤<em>m</em>≤10<sup>4</sup>，1≤<em>t</em>≤10<sup>7</sup>，且1≤<em>m</em>×<em>t</em>≤10<sup>7</sup>，1≤a<sub>i</sub><em>,</em>b<sub>i</sub>≤10<sup>4</sup>。</p><p>转化为等价于价值为k<em>v[i]，花费为k</em>****w[i]的物品</p><p><span class="math display">\[dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*w[i]]+k*v[i])0≤k∗c[i]≤j\]</span></p><h4 id="时间优化">时间优化</h4><p>状态更新的方式决定了物品的数量，从前往后更新,可以更新到已选本身的状态，于是达到无限选择物品目的</p><h3 id="代码-1">代码</h3></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">10000010</span>];<br><span class="hljs-type">int</span> w[<span class="hljs-number">10010</span>],v[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,t;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]) ;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n;i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=w[i]; j&lt;=t; j++) &#123;<br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-w[i]]+<span class="hljs-number">1ll</span>*v[i]);<br>&#125;<br>&#125;<br>    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">    for(int j=W;j&gt;=w[i];j--)&#123;</span><br><span class="hljs-comment">    for(int k=1;k&lt;m[i];k++)&#123;</span><br><span class="hljs-comment">    dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*w[i]]+k*v[i]);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,dp[t]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="思考一下为什么又变成了从前往后更新">思考一下，为什么又变成了从前往后更新</h6><blockquote><p>能用动规解决的问题的特点</p><p>能采用动态规划求解的问题的一般要具有3个性质：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。<br><br><span class="hljs-comment">(2)</span> 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。<br>（<span class="hljs-number">3</span>）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br></code></pre></td></tr></table></figure><p>动规解题的一般思路</p><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态<br><br>            图<span class="hljs-number">1</span> 动态规划决策过程示意图<br><br><span class="hljs-comment">(1)</span>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。<br><br><span class="hljs-comment">(2)</span>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。<br><br><span class="hljs-comment">(3)</span>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。<br><br><span class="hljs-comment">(4)</span>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。<br></code></pre></td></tr></table></figure><p>算法实现的说明</p><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 （2）每个阶段的状态</p><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p><hr><p>版权声明：本文为CSDN博主「zw6161080123」的原创文章，遵循CC 4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zw6161080123/article/details/80639932</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>背包</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/15/hello-world/"/>
    <url>/2022/03/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
